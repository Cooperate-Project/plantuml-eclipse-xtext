/*
* generated by Xtext
*/
package plantuml.eclipse.ui.labeling

import com.google.inject.Inject
import plantuml.eclipse.puml.ClassUml
import plantuml.eclipse.puml.Class
import plantuml.eclipse.puml.Enum
import plantuml.eclipse.puml.Attribute
import plantuml.eclipse.puml.Method
import org.eclipse.xtext.ui.IImageHelper
import plantuml.eclipse.puml.Visibility
import plantuml.eclipse.puml.Classifier
import plantuml.eclipse.puml.Association
import plantuml.eclipse.puml.EnumConstant
import org.eclipse.jface.viewers.StyledString
import plantuml.eclipse.puml.AssociationArrow
import plantuml.eclipse.puml.AssociationTypeLeft
import plantuml.eclipse.puml.AssociationTypeRight

/**
 * Provides labels for a EObjects.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#labelProvider
 */
class PumlLabelProvider extends org.eclipse.xtext.ui.label.DefaultEObjectLabelProvider {

	@Inject
    private IImageHelper imageHelper
    
    private StringBuffer label
    private AssociationArrow arrow  

	@Inject
	new(org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider delegate) {
		super(delegate);
	}
	
	// ==================================================================================
	// ========================== TEXTS FOR LABELS ======================================
	// ==================================================================================

	/**
	 * Returns the label text for the PlantUML-Class-Group
	 */
	def text(ClassUml classUml) {
		"Class Diagram"
	}
	
	/**
	 * Returns the label text for Enums.
	 */
	def text(Enum someEnum){
		return someEnum.name
	}
	
	/**
	 * Returns the label text for enum constants.
	 */
	def text(EnumConstant enumConstant){
		return enumConstant.name
	}
	
	
	/**
	 * Returns the label text for connections.
	 */
	 def text(Association association){
		label = new StringBuffer()
		label.append(association.classLeft.name + " ");
		// Which association do we have?
		arrow = association.associationArrow;
		if(arrow.leftType != AssociationTypeLeft.UNDEFINED){
			label.append(arrow.leftType)
		}
		if(arrow.rightType != AssociationTypeRight.UNDEFINED){
			label.append(arrow.rightType)
		}
		label.append(" " + association.classRight.name);
		if(association.text.length != 0){
			label.append(" : ")
			for(String text : association.text){
				label.append(text)
			}
		}
		return label.toString()
	 }

	/**
	 * Returns the label text for classes.
	 */
	def text(Class someClass) {
		label = new StringBuffer()
		label.append(someClass.getName())
		if(someClass.classifier != null){
			label.append(" {abstract}")
		}
		return label.toString()
	}
		
	/**
	 * Returns the label text for attributes.
	 */
	def text(Attribute attribute){
		var styledLabel = new StyledString()
		styledLabel.append(attribute.getName())
		label = new StringBuffer();
		if(attribute.type != null){
			label.append(" : " + attribute.type)
			if(attribute.array){
				label.append("[")
				if(attribute.length > 0){
					label.append(attribute.length)
				}
				label.append("]")
			}
		}
		if(attribute.classifier != Classifier.UNSPECIFIED){
			if(attribute.classifier == Classifier.ABSTRACT){
				label.append(" {abstract}")
			}
			if(attribute.classifier == Classifier.STATIC){
				label.append(" {static}")
			}
		}
		styledLabel.append(new StyledString(label.toString(), StyledString::DECORATIONS_STYLER))
		return styledLabel
	}
	
	/**
	 * Returns the label text for methods.
	 */
	def text(Method method){
		var styledLabel = new StyledString()
		styledLabel.append(method.getName())
		label = new StringBuffer()
		if(method.type != null){
			label.append(" : " + method.type)
			if(method.array){
				label.append("[")
				if(method.length >= 0){
					label.append(method.length)
				}
				label.append("]")
			}
		}
		if(method.classifier != Classifier.UNSPECIFIED){
			if(method.classifier == Classifier.ABSTRACT){
				label.append(" {abstract}")
			}
			if(method.classifier == Classifier.STATIC){
				label.append(" {static}")
			}
		}
		styledLabel.append(new StyledString(label.toString(), StyledString::DECORATIONS_STYLER))
		return styledLabel
	}
	
	// ==================================================================================
	// ======================= IMAGE ICONS FOR LABELS ===================================
	// ==================================================================================
	
	/**
	 * Returns the image for the PlantUML-Class-Group.
	 */
	def image(ClassUml classUml){
		imageHelper.getImage("java_model_obj.png")
	}
	
	/**
	 * Returns the images for attributes.
	 */
	def image(Attribute attribute){
		if(attribute.visibility == Visibility.PROTECTED){
			imageHelper.getImage("field_protected_obj.png")
		}else if(attribute.visibility == Visibility.PRIVATE){
			imageHelper.getImage("field_private_obj.png")
		}else if(attribute.visibility == Visibility.PUBLIC){
			imageHelper.getImage("field_public_obj.png")
		}else if(attribute.visibility == Visibility.DEFAULT){
			imageHelper.getImage("field_default_obj.png")
		}
	}
	
	/**
	 * Returns the image f√ºr enum constants.
	 */
	 def image(EnumConstant enumConstant){
	 	imageHelper.getImage("field_public_obj.png")
	 }
	
	/**
	 * Returns the images for methods.
	 */
	def image(Method method){
		if(method.visibility == Visibility.PROTECTED){
			imageHelper.getImage("methpro_obj.png")
		}else if(method.visibility == Visibility.PRIVATE){
			imageHelper.getImage("methpri_obj.png")
		}else if(method.visibility == Visibility.PUBLIC){
			imageHelper.getImage("methpub_obj.png")
		}else if(method.visibility == Visibility.DEFAULT){
			imageHelper.getImage("methdef_obj.png")
		}
	}
	
	/**
	 * Returns the image for enums.
	 */
	def image(Enum someEnum){
		imageHelper.getImage("enum_obj.png");
	}
	
	/**
	 * Returns the images for classes.
	 */
	def image(Class someClass){
		if(someClass.interface){
			imageHelper.getImage("int_obj.png")
		}else{
			imageHelper.getImage("class_obj.png")
		}
	}

	
	
}
