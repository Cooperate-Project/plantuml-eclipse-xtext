grammar plantuml.eclipse.Puml hidden(WS, NEWLINE, SL_COMMENT, ML_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate puml "http://www.eclipse.plantuml/Puml"

/**
 * Entry point of the model.
 */
UmlDiagram:
	{UmlDiagram}
	('SEQUENCE' umlDiagrams+=SequenceUml) 
	| ('COMPONENT' umlDiagrams+=ComponentUml)
	| ('CLASS' umlDiagrams+=ClassUml)
;

ClassUml:
	{ClassUml}
	'@startuml' umlElements+=(ClassElement)* '@enduml';

SequenceUml:
	{SequenceUml}
	'@startuml' umlElements+=(UmlElement)* '@enduml';

ComponentUml:
	{ComponentUml}
	'@startuml' umlElements+=(ComponentElement)* '@enduml';
	
	
// ===============================================================================================
// ============== CLASS DIAGRAM ==================================================================
// ===============================================================================================

/*
 * Elements of the class diagram.
 */
ClassElement:
	Class
	| Enum
	| Association;

// TODO: Can't be cross referenced with string names.
Class:
	{Class}
	(classifier='abstract')? ('class' | interface?='interface') name=ClassName
	(color=ColorTag)?
	(('extends' superTypes+=[Class] (',' superTypes+=[Class])*)
	| ('implements' interfaces+=[Class] (',' interfaces+=[Class])?)
	| ('extends' superTypes+=[Class] (',' superTypes+=[Class])* 'implements' interfaces+=[Class] (',' interfaces+=[Class])*))?
	('{' (classContents+=ClassContent)* '}')?;

ClassContent:
	Attribute | Method;

ClassName:
	(ID | STRING);

Enum:
	{Enum}
	'enum' name=ID
	('{' enumConstants+=EnumConstant (',' enumConstants+=EnumConstant)* '}')?;

EnumConstant:
	{EnumConstant}
	name=ID;

// TODO: Visibilities not working with '#' and no white space.
Attribute:
	{Attribute}
	("{" classifier=Classifier "}")? (visibility=Visibility)? name=ID (":" type=ID (array?='[' (length=Int)? ']')?)?;


// TODO: Solve name problems with pre- und postprocessor and not terminal.
// TODO: Visibilities not working with '#' and no white space.
Method:
	{Method}
	 ("{" classifier=Classifier "}")? (visibility=Visibility)? name=METHID
	 (":" type=ID (array?='[' (length=Int)? ']')?)?;

Association:
	{Association}
	(classLeft=[Class|ClassName]
	associationArrow=AssociationArrow
	classRight=[Class|ClassName])
	(':' text+=(ID)*)?;

AssociationArrow:
	{AssociationArrow}
	leftType=AssociationTypeLeft? ('-'|'.') ("[" color=ColorTag "]")? ('-'|'.') rightType=AssociationTypeRight?;

ColorTag:
	color=(COLOR | HEXCODE);

enum AssociationTypeLeft:
	UNDEFINED
	| DIRECTIONAL='<'
	| INHERITANCE='<|'
	| AGGREGATION='o'
	| COMPOSITION='*';

enum AssociationTypeRight:
	UNDEFINED
	| DIRECTIONAL='>'
	| INHERITANCE='|>'
	| AGGREGATION='o'
	| COMPOSITION='*';

enum Visibility: 
	PROTECTED='#'
	| PRIVATE='-'
	| DEFAULT='~'
	| PUBLIC='+';

enum Classifier:
	UNSPECIFIED
	| ABSTRACT='abstract'
	| STATIC='static';


// ===============================================================================================
// ============== SEQUENCE DIAGRAM ===============================================================
// ===============================================================================================

UmlElement:
	Participant
	| UseLeft
	| UseRight
	| Skinparam
	| Box
	| Group
	| Activate
	| Alternative
	| Autonumber
	| Legend
	| Title
	| Newpage
	| Note
	| Divider
	| Reference
	| Delay
	| Space
	//| QualifiedName
;

Participant:
	{Participant}
	// TODO das Problem liegt am Konflikt in den Namen --> Daher hat xtext auch bei der ID den ^ als Konfliktvermeider
	// google: xtext keyword contextual
	// https://kthoms.wordpress.com/2012/03/15/xtext-content-assist-escape-identifiers-conflicting-with-keywords/#comments
	//	'participant ' (name=TEXT | longname=(STRING | TEXT) ' as ' name=TEXT) NEWLINE
	//	'participant ' {UmlParticipant} name=(TEXT|STRING) ('as ' name=TEXT)? NEWLINE
	('PARTICIPANT' | 'ACTOR' | 'BOUNDARY' | 'CONTROL' | 'ENTITY' | 'DATABASE') (name=ID | longname=(STRING | ID) 'AS'
	name=ID);

QualifiedName:
	{QualifiedName}
	ID;

Space:
	{Space}
	('||' value=ID '||' | '|||');

Delay:
	{Delay}
	'...' value+=(ID)* '...';

Reference:
	{Reference}
	'REF OVER' ref+=[Participant|ID] (',' ref+=[Participant|ID])*
	(':' value+=(ID)* | value+=(ID)* 'END REF');

Divider:
	{Divider}
	'==' name=ID value+=(ID)* '==';

Note:
	{Note}
	'NOTE' ('LEFT' | 'RIGHT' | 'OVER') ('OF' noteOf=[Participant|ID])?
	value+=(ID)*
	'END NOTE';

Newpage:
	{Newpage}
	'NEWPAGE' value+=(ID | STRING)*;

Title:
	{Title}
	'TITLE' value+=(ID | STRING)*;

Legend:
	{Legend}
	'LEGEND'
	legendEntries+=(STRING | ID | '=' | ':')*
	'ENDLEGEND';

LegendEntries:
	name=ID '=' value+=(ID | STRING)*;

Autonumber:
	'AUTONUMBER' (value=(ID | STRING))?;

Activate returns UmlElementsContainer:
	{Activate}
	'ACTIVATE' activate=[Participant]
	umlElements+=(UmlElement)*
	('DEACTIVATE' | 'DESTROY') deactivate=[Participant];

Alternative returns UmlElementsContainer:
	{Alternative}
	'ALT' text+=(ID)*
	umlElements+=(UmlElement)*
	elseBlocks+=(Else)*
	=> 'END';

Else returns UmlElementsContainer:
	{Else}
	'ELSE' text+=(ID)*
	umlElements+=(UmlElement)*;

Group returns UmlElementsContainer:
	{Group}
	('GROUP' | 'OPT' | 'LOOP' | 'PAR' | 'BREAK' | 'CRITICAL') test+=(ID)*
	umlElements+=(UmlElement)*
	=> 'END';

Box returns UmlElementsContainer:
	{Box}
	'BOX' name=STRING (color=HEXCODE)?
	umlElements+=(UmlElement)*
	=> 'END BOX';

Skinparam:
	{Skinparam}
	'SKINPARAM SEQUENCE{'
	skinElements+=(SkinElement)*
	'}';

SkinElement:
	name=ID value=(ID | HEXCODE);

UseLeft returns UmlUse:
	{UseLeft}
	(userOne=[Participant|ID] | '[') ('o<-' | '<-o' | 'o<-o' | '<-' | 'o<--' | '<--o' | 'o<--o' | '<--' | 'x<-' | '<-x' |
	'x<-x' | 'x<--' | '<--x' | 'x<--x') userTwo=[Participant|ID] (':' text+=(ID)*)?;

UseRight returns UmlUse:
	{UseRight}
	(userOne=[Participant|ID]) ('o->' | '->o' | 'o->o' | '->' | 'o-->' | '-->o' | 'o-->o' | '-->' | 'x->' | '->x' |
	'x->x' | 'x-->' | '-->x' | 'x-->x') (userTwo=[Participant|ID] | ']') (':' text+=(ID)*)?;


	
UmlElementsContainer:
	{UmlElementsContainer}
	umlElements+=(UmlElement)*;

NamedElement:
	{NamedElement}
	name=ID;

UmlUse:
	{UmlUse};


// ===============================================================================================
// ============== COMPONENT DIAGRAM ==============================================================
// ===============================================================================================	

ComponentElement:
	Component
	| Interface
	| Link
	| Title;
	
Link:
	linkOne=[NamedElement|ID] ('-' | '<-' | '.' | '<.') (ID | '[' HEXCODE ']')* ('-' | '.' | '->' | '.>') linkTwo=[NamedElement|ID] (':'
	text+=(ID)*)?;

Interface returns NamedElement:
	{Interface} ('()' | 'INTERFACE') description=STRING ('AS' name=ID)? (color=HEXCODE)?;

Component returns NamedElement:
	{Component} '[' name=ID nameExtension+=(ID)* ']' ('AS' name=ID)? (color=HEXCODE)?;


// ===============================================================================================
// ============== SHARED RULES AND TERMINALS =====================================================
// ===============================================================================================

// https://github.com/EricssonPlant/plantuml-xtext-light/
terminal COLOR:
	"#" ('AliceBlue'|'AntiqueWhite'|'Aqua'|'Aquamarine'|'Azure'|'Beige'|'Bisque'|'Black'|'BlanchedAlmond'
	|'Blue'|'BlueViolet'|'Brown'|'BurlyWood'|'CadetBlue'|'Chartreuse'|'Chocolate'|'Coral'
	|'CornflowerBlue'|'Cornsilk'|'Crimson'|'Cyan'|'DarkBlue'|'DarkCyan'|'DarkGoldenRod'|'DarkGray'
	|'DarkGreen'|'DarkGrey'|'DarkKhaki'|'DarkMagenta'|'DarkOliveGreen'|'DarkOrchid'|'DarkRed'
	|'DarkSalmo'|'DarkSeaGreen'|'DarkSlateBlue'|'DarkSlateGray'|'DarkSlateGrey'|'DarkTurquoise'
	|'DarkViolet'|'Darkorange'|'DeepPink'|'DeepSkyBlue'|'DimGray'|'DimGrey'|'DodgerBlue'
	|'FireBrick'|'FloralWhite'|'ForestGreen'|'Fuchsia'|'Gainsboro'|'GhostWhite'|'Gold'
	|'GoldenRod'|'Gray'|'Green'|'GreenYellow'|'Grey'|'HoneyDew'|'HotPink'|'IndianRed'
	|'Indigo'|'Ivory'|'Khaki'|'Lavender'|'LavenderBlush'|'LawnGreen'|'LemonChiffon'
	|'LightBlue'|'LightCoral'|'LightCyan'|'LightGoldenRodYellow'|'LightGray'|'LightGreen'
	|'LightGrey'|'LightPink'|'LightSalmon'|'LightSeaGreen'|'LightSkyBlue'|'LightSlateGray'
	|'LightSlateGrey'|'LightSteelBlue'|'LightYellow'|'Lime'|'LimeGreen'|'Linen'|'Magenta'
	|'Maroon'|'MediumAquaMarine'|'MediumBlue'|'MediumOrchid'|'MediumPurple'|'MediumSeaGreen'
	|'MediumSlateBlue'|'MediumSpringGreen'|'MediumTurquoise'|'MediumVioletRed'
	|'MidnightBlue'|'MintCream'|'MistyRose'|'Moccasin'|'NavajoWhite'|'Navy'|'OldLace'
	|'Olive'|'OliveDrab'|'OrangeRed'|'Orchid'|'PaleGoldenRod'|'PaleGreen'
	|'PaleTurquoise'|'PaleVioletRed'|'PapayaWhip'|'PeachPuff'|'Peru'|'Pink'|'Plum'
	|'PowderBlue'|'Purple'|'Red'|'RosyBrown'|'RoyalBlue'|'SaddleBrown'
	|'Salmon'|'SandyBrown'|'SeaGreen'|'Sienna'|'Silver'|'SkyBlue'|'SlateBlue'
	|'SlateGray'|'SlateGrey'|'Snow'|'SpringGreen'|'SteelBlue'|'Tan'|'Teal'|'Thistle'
	|'Tomato'|'Turquoise'|'Violet'|'Wheat'|'White'|'WhiteSmoke'|'Yellow'|'YellowGreen');

terminal HEXCODE:
	"#"
	('A' .. 'F'|'0' .. '9')('A' .. 'F'|'0' .. '9')('A' .. 'F'|'0' .. '9')
	('A' .. 'F'|'0' .. '9')('A' .. 'F'|'0' .. '9')('A' .. 'F'|'0' .. '9');

terminal METHID:
	('a'..'z' | 'A'..'Z' | '_' | '0'..'9' | '\"\"' | '*' | '//' | '<' | '>' | '\\') 
	('a'..'z' | 'A'..'Z' | '_' | '0'..'9' | '\"\"' | '-' | '~' | '*' | '//' | '<' | '>' | '\\' | ':' | '.' | ',')*
	"("
	('a'..'z' | 'A'..'Z' | '_' | '0'..'9' | '\"\"' | '-' | '~' | '*' | '//' | '<' | '>' | '\\' | ':' | '.' | ',')*
	")";

// TODO: Funktioniert noch nicht.
terminal ML_COMMENT:
	"//'" ('\r'? '\n')* "'//" ;

Int returns ecore::EInt:
	NUMBER;

terminal NUMBER:
	'0'..'9'+;

terminal STRING:
	'"' ('\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\' | '"'))* '"';

terminal WS:
	' ' | '\t';

terminal NEWLINE:
	'\r'? '\n';

terminal ID:
	('a'..'z' | 'A'..'Z' | '_' | '0'..'9' | '\"\"' | '//' | '\\')
	('a'..'z' | 'A'..'Z' | '_' | '0'..'9' | '\"\"' | '//' | '\\' | ':')*;

terminal SL_COMMENT:
	"'" !('\n' | '\r')* ('\r'? '\n')?;

